<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="./three.min.js"></script>
    <script src="./DeviceOrientationControls.js"></script>
    <script src="./OrbitControls.js"></script>
    <script src="./StereoEffect.js"></script>
    <script src="./helvetiker_regular.typeface.js"></script>
    <script src="https://timezonedb.googlecode.com/files/timezonedb.js" type="text/javascript"></script>
</head>

<body>
    <!-- Plotly chart will be drawn inside this DIV -->
    <div id="rev" style="width:100%;height:100%"></div>
    <script>
        var data = [
  {
    z: [[0,0,0,1.44],
    [1.49,1.92,2.28,2.11],
    [2.42,2.37,2.77,2.26],
    [2.22,2.31,2.5,1.91],
    [2.18,2.18,2.5,2.06],
    [2.16,2.27,2.64,2.2],
    [2.17,2.48,2.61,2.34],
    [2.26,2.68,2.8,2.51],
    [2.4,2.99,3.02,2.84],
    [2.9,3.49,3.56,3.15],
    [3.31,3.72,3.86,3.47],
    [3.61,4.01,4.19,3.82],
    [3.93,4.38,4.66,4.34],
    [4.54,5.09,5.43,4.59],
    [4.44,4.71,4.8,4.41],
    [4.73,5.08,5.18,4.84],
    [5.08,5.77,6.08,5.73],
    [5.85,6.47,6.67,5.96],
    [6.19,6.7,6.97,6.43],
    [6.97,7.43,7.98,7.38],
    [7.46,7.78,8.41,7.69]],
    type: 'surface',
    colorscale: [[0, "rgb(231, 245, 255)"], [1, "rgb(31, 119, 180)"]],
    showscale: false
  }
],
layout = {
  title: 'Nike revenue',
  autosize: false,
  width: 1600,
  height: 1100,
  margin: {
    l: 20,
    r: 20,
    b: 60,
    t: 60
  },
  center: {
      x:0,
      y:0,
      z:0
  }
};

//Plotly.newPlot('rev', data, layout);

var scene,
          camera, 
          renderer,
          element,
          container,
          effect,
          controls,
          clock,

          lastColorRange = [0, 0.3],
          currentColorRange = [0, 0.3],

          // City and weather API set up
          cities = [['Sydney', '2147714'], ['New York', '5128638'], ['Tokyo', '1850147'], ['London', '2643743'], ['Mexico City', '3530597'], ['Miami', '4164138'], ['San Francisco', '5391959'], ['Rome', '3169070']],
          cityWeather = {},
          cityTimes = [],
          currentCity = 0,
          currentCityText = new THREE.TextGeometry(),
          currentCityTextMesh = new THREE.Mesh();

      init();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.001, 700);
        camera.position.set(0, 15, 0);
        scene.add(camera);

        renderer = new THREE.WebGLRenderer();
        element = renderer.domElement;
        container = document.getElementById('rev');
        container.appendChild(element);

        effect = new THREE.StereoEffect(renderer);

        // Our initial control fallback with mouse/touch events in case DeviceOrientation is not enabled
        controls = new THREE.OrbitControls(camera, element);
        controls.target.set(
          camera.position.x + 0.15,
          camera.position.y,
          camera.position.z
        );
        controls.noPan = true;
        controls.noZoom = true;

        // Our preferred controls via DeviceOrientation
        function setOrientationControls(e) {
          if (!e.alpha) {
            return;
          }

          controls = new THREE.DeviceOrientationControls(camera, true);
          controls.connect();
          controls.update();

          element.addEventListener('click', fullscreen, false);

          window.removeEventListener('deviceorientation', setOrientationControls, true);
        }
        window.addEventListener('deviceorientation', setOrientationControls, true);

        var cube = new THREE.Mesh( new THREE.BoxGeometry( 50, 50, 50 ), new THREE.MeshLambertMaterial( {color: 0x8888ff} ) );
	    cube.position.set(-100,-50,-50);
        scene.add(cube);
        
        clock = new THREE.Clock();

        animate();
      }

      

      function lookupTimezones(t, len) {
        var tz = new TimeZoneDB;
        
        tz.getJSON({
            key: "GPH4A5Q6NGI1",
            lat: cityWeather[t].coord.lat,
            lng: cityWeather[t].coord.lon
        }, function(timeZone){
            cityTimes.push(new Date(timeZone.timestamp * 1000));

            t++;
            if (t < len) lookupTimezones(t, len);
            else applyWeatherConditions();
        });
      }

      function applyWeatherConditions() {
        displayCurrentCityName(cities[currentCity][0]);

        var info = cityWeather[currentCity];

        var timeThere = cityTimes[currentCity] ? cityTimes[currentCity].getUTCHours() : 0,
            isDay = timeThere >= 6 && timeThere <= 18;

        if (isDay) {
          switch (info.weather[0].main) {
            case 'Clouds':
              currentColorRange = [0, 0.01];
              break;
            case 'Rain':
              currentColorRange = [0.7, 0.1];
              break;
            case 'Clear':
            default:
              currentColorRange = [0.6, 0.7];
              break;
          }
        } else {
          currentColorRange = [0.69, 0.6];
        }

        if (currentCity < cities.length-1) currentCity++;
        else currentCity = 0;

        setTimeout(applyWeatherConditions, 5000);
      }

      function displayCurrentCityName(name) {
        scene.remove(currentCityTextMesh);

        currentCityText = new THREE.TextGeometry(name, {
          size: 4,
          height: 1
        });
        currentCityTextMesh = new THREE.Mesh(currentCityText, new THREE.MeshBasicMaterial({
          color: 0xffffff, opacity: 1
        }));

        currentCityTextMesh.position.y = 10;
        currentCityTextMesh.position.z = 20;
        currentCityTextMesh.rotation.x = 0;
        currentCityTextMesh.rotation.y = -180;

        scene.add(currentCityTextMesh);
      }

      function animate() {
        var elapsedSeconds = clock.getElapsedTime();

        // We check if the color range has changed, if so, we'll change the colours
        if (lastColorRange[0] != currentColorRange[0] && lastColorRange[1] != currentColorRange[1]) {

          lastColorRange = currentColorRange;
        }

        requestAnimationFrame(animate);

        update(clock.getDelta());
        render(clock.getDelta());
      }

      function resize() {
        var width = container.offsetWidth;
        var height = container.offsetHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize(width, height);
        effect.setSize(width, height);
      }

      function update(dt) {
        resize();

        camera.updateProjectionMatrix();

        controls.update(dt);
      }

      function render(dt) {
        effect.render(scene, camera);
      }

      function fullscreen() {
        if (container.requestFullscreen) {
          container.requestFullscreen();
        } else if (container.msRequestFullscreen) {
          container.msRequestFullscreen();
        } else if (container.mozRequestFullScreen) {
          container.mozRequestFullScreen();
        } else if (container.webkitRequestFullscreen) {
          container.webkitRequestFullscreen();
        }
      }
      
      

        

    </script>
</body>

</html>